.include"m328PBdef.inc"

.def del_high=r25
.def del_low=r24
.def freq=r23
.def cnt=r22
.def prevADCH=r21
.def prevADCL=r20
.def dec2=r19
.def dec1=r18
.def dec0=r17
.def temp=r16

.equ f_CPU = 16					; f = 16 MHz
.equ LCD_RS = 2
.equ LCD_E = 3
.equ LCD_DB4 = 4
.equ LCD_DB5 = 5
.equ LCD_DB6 = 6
.equ LCD_DB7 = 7

.org 0x0
rjmp reset
.org 0x02A
rjmp ISR_ADC

reset:
    ; init stack pointer
    ldi temp, low(RAMEND)
    out SPL, temp
    ldi temp, high(RAMEND)
    out SPH, temp
    
    ; ADC enable, no conversion, ADCIE = 1, prescaler = 128 => fADC = 125kHz
    ldi temp, 0b10001111
    sts ADCSRA, temp
    
    ; Vref = 5V, ADLAR = 0, ADC1 -> PC1
    ldi temp, 0b01000001
    sts ADMUX, temp
    
    ; Enable Global Interrupts
    sei
    
    ; set PINC1 as ADC input
    cbi DDRC, 1

	; set PORTD as output
	ser temp
	out DDRD, temp

	out DDRB, temp

start_conv:						; start adc conversion
    lds temp, ADCSRA
    ori temp, (1<<ADSC)
    sts ADCSRA, temp

wait_adc:						; wait until the adc conversion ends
    lds temp, ADCSRA
    sbrc temp, ADSC
    rjmp wait_adc
    
    ldi del_low, low(1000)
    ldi del_high, high(1000)
    rcall wait_msec				; delay 1 sec
    rjmp start_conv

; ISR_ADC
ISR_ADC:
	
	in temp, SREG
	push temp

    lds temp, ADCL
	cp prevADCL, temp
	brne new_conv
	lds temp, ADCH
    cp prevADCH, temp
	brne new_conv

	rjmp return_home

new_conv:						; change the DDRAM's content
	lds prevADCL, ADCL
	lds prevADCH, ADCH			; change the prevADC value

	mov XL, prevADCL
	mov XH, prevADCH

	lsr XH
	ror XL						; X = ADC / 2

	; GOAL = ADC * 500/1024 = ADC * 125/256 = ADC * 5 * 25 / 256 = ADC * [ (1 + 2^2) * (1 + 2^3 + 2^4) / (2^4 * 2^4) ]
/*
	ldi cnt, 4
	rcall shift_right_double	; X = ADC / 16

	mov YL, XL
	mov YH, XH					; Y = X

	ldi cnt, 2
	rcall shift_left_double		; X = ADC * 2^2 / 16

	add XL, YL
	adc XH, YH					; X = ADC * 5 / 16

	mov YL, XL
	mov YH, XH					; Y = X

	ldi cnt, 4
	rcall shift_right_double	; X = ADC * 5 / (16 * 16)

	mov YL, XL
	mov YH, XH					; Y = X

	ldi cnt, 4
	rcall shift_left_double		; X = ADC * 5 * (2^4) / (16 * 16)

	mov ZL, XL
	mov ZH, XH					; Z = X

	mov XL, YL
	mov XH, XL					; X = Y

	ldi cnt, 3
	rcall shift_left_double		; X = ADC * 5 * (2^3) / (16 * 16)

	add XL, ZL
	adc XH, ZH					; X = ADC * 5 * (2^4 + 2^3) / (16 * 16)

	add XL, YL
	adc XH, YH					; X = ADC * 5 * (2^4 + 2^3 + 1) / (16 * 16)
*/

	ldi dec0, 0
	ldi dec1, 0
	ldi dec2, 0

	ldi YL, 100
	ldi YH, 0

loop2:
	cpi XH, 0
	brne xh_non_zero
	cpi XL, 100
	brlo loop1

xh_non_zero:
	sub XL, YL
	sbc XH, YH
	inc dec2
	rjmp loop2

loop1:
	cpi XL, 10
	brlo dec0_found
	sbiw XL, 10
	inc dec1
	rjmp loop1

dec0_found:
	mov dec0, XL

	ldi r24, '0'
	add r24, dec2
	rcall lcd_data

	ldi r24, '.'
	rcall lcd_data

	ldi r24, '0'
	add r24, dec1
	rcall lcd_data

	ldi r24, '0'
	add r24, dec0
	rcall lcd_data

return_home:
	ldi r24, 2
	rcall lcd_command			; don't change the DDRAM's contents

	ldi del_low, low(1530)
    ldi del_high, high(1530)
    rcall wait_usec				; delay 1.53 msec

	pop temp
	out SREG, temp

	reti

; =============================================  SUBROUTINES ===================================================

; write_2_nibbles
write_2_nibbles:
	push r24
	in r25, PIND
	andi r25, 0x0f
	andi r24, 0xf0
	add r24, r25
	out PORTD, r24

	sbi PORTD, LCD_E
	nop
	nop
	cbi PORTD, LCD_E

	pop r24
	swap r24
	andi r24, 0xf0
	add r24, r25
	out PORTD, r24

	sbi PORTD, LCD_E
	nop
	nop
	cbi PORTD, LCD_E

	ret

; lcd_init
lcd_init:
	ldi del_low ,low(200)
    ldi del_high ,high(200)
    rcall wait_msec				; delay 200 msec
    
    ldi r24, 0x30				; command to switch to 8 bit mode 
    out PORTD, r24
    sbi PORTD, LCD_E			; Enable  Pulse 
    nop
    nop
    cbi PORTD ,LCD_E
    ldi del_low, 250
    ldi del_high, 0	 
    rcall wait_usec				; delay 250 usec
     
    ldi r24, 0x30				; command to switch to 8 bit mode 
    out PORTD, r24
    sbi PORTD, LCD_E			; Enable  Pulse 
    nop
    nop
    cbi PORTD ,LCD_E
    ldi del_low, 250
    ldi del_high, 0	 
    rcall wait_usec				; delay 250 usec

	ldi r24, 0x30				; command to switch to 8 bit mode 
    out PORTD, r24
    sbi PORTD, LCD_E			; Enable  Pulse 
    nop
    nop
    cbi PORTD ,LCD_E
    ldi del_low, 250
    ldi del_high, 0	 
    rcall wait_usec				; delay 250 usec

	ldi r24, 0x30				; command to switch to 4 bit mode 
    out PORTD, r24
    sbi PORTD, LCD_E			; Enable  Pulse 
    nop
    nop
    cbi PORTD ,LCD_E
    ldi del_low, 250
    ldi del_high, 0	 
    rcall wait_usec				; deay 250 usec

	ldi r24, 0x28
	rcall lcd_command			; 5x8 dots, 2 lines

	ldi r24, 0x0c
	rcall lcd_command			; display on, cursor off

	rcall lcd_clear_display		; clear display

	ldi r24, 0x06
	rcall lcd_command			; increase address, no display shift

	ret

; lcd_data
lcd_data:
	sbi PORTD, LCD_RS			; LCD_RS = 1
	rcall write_2_nibbles		; send data
	ldi del_low, 250
	ldi del_high, 0
	rcall wait_usec				; delay 250 usec
	ret

; lcd_command
lcd_command:
	cbi PORTD, LCD_RS			; LCD_RS = 0
	rcall write_2_nibbles		; send command
	ldi del_low, 250
	ldi del_high, 0
	rcall wait_usec				; delay 250 usec
	ret

; lcd_clear_display
lcd_clear_display:
	ldi r24, 0x01
	rcall lcd_command			; clear dispaly command
	ldi del_low, low(5)
	ldi del_high, high(5)
	rcall wait_msec				; delay 5 msec
	ret

; wait_msec
wait_msec:						; 1 ms = f_CPU * 1000 cycles
    ldi freq, f_CPU
loop_out:
    ldi cnt, 249
loop_inn:
    dec cnt
    nop
    brne loop_inn
    dec freq
    brne loop_out
    sbiw del_low, 1
    brne wait_msec
    ret

; wait_usec
wait_usec:						; 1 us = f_CPU cycles
    ldi cnt, (f_CPU>>2)
loop:							; del_loop = 4 * f_CPU/4 cycles
    nop
    dec cnt
    brne loop
    sbiw del_low, 1
    brne wait_usec
    ret

; shift_left_double
shift_left_double:				; multiply double register
	lsl XL
	rol XH
	dec cnt
	brne shift_left_double
	ret

; shift_right_double
shift_right_double:				; devide double register
	lsr XH
	ror XL
	dec cnt
	brne shift_right_double
	ret
